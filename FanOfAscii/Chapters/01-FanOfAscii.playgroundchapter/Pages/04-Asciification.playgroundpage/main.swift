//#-hidden-code
//
// Copyright Â© 2020 Bunny Wong
// Created on 2019/12/18.
//

import UIKit
import PlaygroundSupport

import BookAPI
import BookCore

PlaygroundPage.current.needsIndefiniteExecution = true

//#-end-hidden-code
/*:
# The â€œASCIIficationâ€ Magic

## Character Map

ASCII art can be generated by substituting pixels in different brightness levels with ASCII characters. To achieve
desired result, the font must be **monospaced**, which has fixed width for all characters.

Here is a **character map** built with font â€œFira Codeâ€, by arranging characters to fit a gradient from white to black.

ï¼ˆå›¾ï¼‰

*/
//#-editable-code

let characterMap = "MWNXK0Okxdolc:;,'...   "

//#-end-editable-code
/*:
## Resampling

Since characters are much wider than pixels, images have to be shrunken the before mapping to ASCII characters.
Technically, scaling down an image is known as **downsampling** or broadly speaking, **resampling**. When scaling an
image, different *scaling algorithms* can applied. Most of them takes nearby pixels into consideration to produce a
smooth result.

### ðŸ”¬Scaling & Resampling

* Experiment:
    * Following code snippet shrinks an image according to the aspect ratio of characters.
    * Run the code and tap the *shrink* button to see the effect. Try tapping the buttonpir at the lower right corner,
    notice how pixels are resampled when scaling a small image up.
*/
//#-editable-code

// The aspect ratio of characters in the font â€œFira Codeâ€
let ratio = 1.70667

func calculateCharacterRows(rawImage: RawImage, charactersPerRow: Int) -> Int {
    let scaledHeight = Double(rawImage.format.height) * Double(charactersPerRow) / Double(rawImage.format.width)
    return Int((scaledHeight / ratio).rounded())
}

let charactersPerRow = 80
let characterRows = 0

func scaleImageForAsciification(rawImage: RawImage) -> RawImage? {
    characterRows = calculateCharacterRows(rawImage: rawImage, charactersPerRow: charactersPerRow)
    // Scale the image to match the dimension of resulting ASCII art.
    return rawImage.scaled(width: charactersPerRow, height: characterRows)
}

//#-end-editable-code
/*:
## Final Magic

### ðŸ”¨Mapping Pixels with Characters

* Experiment:
    * In this experiment, we'll build another filter to turn an image into grayscaled version, with consideration.
    * Try to read and complete the following code snippet. When you finish, run your code and tap the *Switch to
    Grayscale* button below the image to see whether it works.
*/
//#-editable-code

func applyAsciification(rawImage: RawImage) -> UIImage? {
    let brightnessLevels = Double(characterMap.count)
    var asciificationResult: String = ""
    for y in 0..<characterRows {
        for x in 0..<charactersPerRow {
            if var pixel = rawImage.pixelAt(x: x, y: y) {
                let mappedBrightnessValue = pixel.brightness / 255.0 * (brightnessLevels - 1)
                asciificationResult.append(Array(characterMap)[Int(mappedBrightnessValue.rounded())])
            }
        }
        asciificationResult += "\n"
    }
    return RawImage.renderAsciifiedImage(
            asciificationResult,
            font: FiraCode.bold.rawValue,
            size: 14,
            charactersInRow: charactersPerRow,
            rows: characterRows,
            characterRatio: ratio)
}

//#-end-editable-code
/*:
* Note:
    In this code snippet, we transform the image by multiplying it with a custom filter matrix. If you're not familiar
    with limier algebra, the following figure will explain how this transform matrix works.
*/
////#-hidden-code
FiraCode.registerFont()

let remoteView = remoteViewAsLiveViewProxy()
let eventListener = EventListener(proxy: remoteView) { message in
    switch message {
    case .shrinkingRequest(let image):
        guard let rawImage = RawImage(uiImage: image) else {
            return
        }
        let destinationBitmapInfo = CGBitmapInfo(rawValue: CGImageAlphaInfo.premultipliedLast.rawValue)
        if let destRawImage = scaleImageForAsciification(rawImage: rawImage),
           let destCGImage = destRawImage.cgImage(bitmapInfo: destinationBitmapInfo) {
            remoteView?.send(EventMessage.imageProcessingResponse(image: UIImage(cgImage: destCGImage)).playgroundValue)
        }
    case .asciificationRequest(let image):
        guard let rawImage = RawImage(uiImage: image) else {
            return
        }
        if let destImage = applyAsciification(rawImage: rawImage) {
            remoteView?.send(EventMessage.imageProcessingResponse(image: destImage).playgroundValue)
        }
    default:
        break
    }
}
////#-end-hidden-code
